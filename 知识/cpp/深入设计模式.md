
# 面向对象程序设计基础

![[Pasted image 20240228143711.png]]
1、抽象：对现实中的物体进行相关属性的抽象
2、封装：一个对象对其他对象隐藏部分状态和行为，仅仅暴露有限的接口。例如引擎盖。
3、继承：根据已有的类创建新的类，代码复用
4、多态：通过父类对象表示子类对象。对不同子类进行抽象



# 对象之间的关系


## 依赖

一个对象当作参数，传递到了另外一个类的方法中进行了方法调用。如果这个对象进行了改动，那么那个方法会出现致命错误

## 关联

相当于类中的属性，如果进行了改动，外部类中调用方法也会出现致命错误

## 聚合

主要是描述一对多，多对多，整体对部分的关系。
除了包含这部分之外，还可以包含其他的东西。这就是与组合最大的区别。，空心菱形表示

## 组合

例如， 汽车是由很多零部件组成的
除了这些零部件之外，没有包含其他的东西，这就是组合。用实心菱形表示

## 总结
![[Pasted image 20240228144805.png]]

1. 依赖：对类 B 进行修改会影响到类 A 。
2. 关联：：对象 A 知道对象 B。类 A 依赖于类 B。
3. 聚合：对象 A 知道对象 B 且由 B 构成。类 A 依赖于类 B。
4. 组合：对象A 知道对象B、由B 构成而且管理着B 的生命周
期。类 A 依赖于类 B。
5. 实现：类A 定义的方法由接口B 声明。对象A 可被视为对象
B。类 A 依赖于类 B。
6. 继承：类A 继承类B 的接口和实现， 但是可以对其进行扩
展。对象 A 可被视为对象 B。类 A 依赖于类 B。



# 软件设计原则


## 优秀设计的特征

### 代码复用

代码复用是减少开发成本最好的方式， 其意图非常明显：与其反复从头开发，不如在新对象中重用已有代码。
### 拓展性

变化是程序员生命中唯一不变的事情

在设计程序架构的时候，最好能够支持未来任何可能变更的方式。


## 设计原则
### 封装变化的内容

找到程序中变化的内容并将其与不变的内容区分开，后面只需要修改变化的内容，而不需要关心不变的内容。

#### 方法层面的封装
![[Pasted image 20240228150648.png]]
![[Pasted image 20240228150702.png]]


#### 类层面的封装

![[Pasted image 20240228150732.png]]

![[Pasted image 20240228150743.png]]
这样设计，将订单中的不变部分封装起来，对计算方式中以后会变的部分也封装起来


### 面向接口进行开发

**面向接口开发，而不是面向实现，依赖抽象类型，而不是具体的类**

可以对具体对象的依赖，拥有更好的可拓展性
![[Pasted image 20240228150937.png]]


![[Pasted image 20240228150924.png]]


![[Pasted image 20240228150950.png]]



### 组合优于继承

继承这件事通常只有在程序中已包含大量类，且修改任何东西都非常困难时才会引起关注。

继承的缺点：
1. 子类必须实现父类中所有的接口，没用的也要实现
2. 重写方法的时候，需要确保与超类的版本兼容
3. 打破了超类的封装，可以访问父类中的详细内容
4. 子类和父类紧密耦合
5. 类层次结构的膨胀，多个维度进行组合。
![[Pasted image 20240228152115.png]]
出现这种是因为，不允许继承多个父类。但允许实现多个接口

![[Pasted image 20240228152235.png]]



### SOLID原则
有原则是件好事，但是也要时刻从实用的角度来考量，不要把这里的每句话当作放之四海皆准的教条。

#### 单一职责原则

尽量让每个类中只负责软件中的一个功能，并将这个功能完全封装在这个类中。
优点：代码架构清晰，改动的时候修改量少

![[Pasted image 20240228152850.png]]
改动理由，时间表报告的格式可能会随着时间而改变，从而使你需要对类中的代码进行修改。

![[Pasted image 20240228152901.png]]


#### 开闭原则

开放拓展，关闭修改：在实现新功能时能保持已有代码不变。

![[Pasted image 20240228153059.png]]

![[Pasted image 20240228153111.png]]

策略模式


#### 里氏替换原则

子类需要保持与父类的行为的兼容。而不是进行完全替换，需要拓展子类功能。


包含内容：
1. 子类的方法参数类型，应该与其超类参数相匹配或者更加抽象
2. 子类的方法的返回值类型必须比超累的返回值类型兼容或更低层次
3. 子类的方法不应该抛出基础方法预期之外的异常。 可能会穿透防御，。
4. 子类不应该加强前置条件。
	1. 例如父类要求整数，子类要求参数为正整数。这样就会使得程序出错
5. 子类也不能削弱后置条件
6. 父类的不变量必须保留
7. 子类不能修改父类中的私有变量成员。？  这不太可能

违反的例子

![[Pasted image 20240228160107.png]]

![[Pasted image 20240228160131.png]]



#### 接口隔离原则

客户端不应被强迫依赖于不使用的方法

![[Pasted image 20240228160506.png]]
![[Pasted image 20240228160553.png]]
与其他原则一样，你可能会过度使用这条原则。不要进一步划分已经非常具体的接口。记住，创建的接口越多，代码就越复杂。因此要保持平衡。


#### 依赖倒置原则

高层次的类不应该依赖于低层次的类
两者都应该依赖于抽象接口
抽象接口不应该依赖于具体的实现
具体的实现应该依赖于抽象的接口

![[Pasted image 20240228161101.png]]

![[Pasted image 20240228161114.png]]






# 设计模式目录

## 创建型模式
提供对象的创建方法，提高灵活和可复用性

### 工厂方法
父类中提供一个创建对象的接口，允许子类决定实例化对象的类型。
![[Pasted image 20240228162139.png]]


适用范围：
1. 复用创建的对象，解决多次创建销毁。
2. 创建对象的时候，无法预知对象的确切类型的时候
3. 需要未来拓展更多的内部组件的时候
实现方式：
1. 所有产品都有统一的接口， 继承父类
2. 在Creator中添加一个空的工厂（创建）方法，返回类型为通用产品类型
3. 在具体的产品工厂中，

优缺点：
 > 优点
1. 避免创建者和产品之间的耦合
2. 单一职责原则
3. 开闭原则
> 缺点
1. 需要引入许多新的子类，代码变得更复杂

### 抽象工厂
能够创建一系列相关的对象，而无需指定具体类

![[Pasted image 20240228170148.png]]
实际上就是对工厂类，再进行了一个层次的抽象

### 生成器（builder）
能够分步骤创建复杂的对象
生成器模式让你能够分步骤创建复杂对象。生成器不允许其他对象访问正在创建中的产品。

![[Pasted image 20240228170652.png]]


### 原型
能够复制已有的对象，但无需依赖他们所属的类

![[Pasted image 20240228174235.png]]
添加一个clone 接口，每一个继承下来的必须要实现clone方法

但是当clone的对象有循环引用的时候会非常复杂


### 单例
保证一个类只有一个对象，并且提供一个访问改实例的全局接口

![[Pasted image 20240228180142.png]]
或者使用 magic static 来简单的实现，这是最简单的。
如果普通的实现，必须要Double-Checked Locking
>为什么需要双重，单重不行？
1. 并不是加锁两次，而是检查两次对象是否为空



## 结构型模式
介绍了如何将对象和类组装成较大的结构，同时保持结构的灵活和高效。

### 适配器
让接口不兼容的对象能够相互作用

![[Pasted image 20240229092645.png]]


### 桥接
把一个大类拆分为抽象和实现两个独立的层次结构，能够再开发时候分别使用


### 组合
将对象组合成树状结构，并且能够轻松使用


### 装饰器
将对象放入包含 特殊行为的封装中


### 外观
能够为程序库，框架或者其他复杂类提供简单的接口


### 享元
摒弃再每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，能够在有限的内存容量中保存更多的对象。类似于联合体吗？

### 代理
提供对象的替代品，代理控制对原对象的访问，并允许再将请求提交给对象前后进行一些处理。












