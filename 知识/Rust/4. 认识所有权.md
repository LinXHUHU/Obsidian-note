
- 核心功能（之一）是 **所有权**（_ownership_）
	- 管理其使用计算机内存的方式
	- 垃圾回收机制
	- 亲自分配和释放内存
	- 通过所有权系统管理内存
		- 优点 ：在运行时，所有权系统的任何功能都不会减慢程序。 





---

- **所有权的规则**
	- Rust 中的每一个值都有一个被称为其 **所有者**（_owner_）的变量
	- 值在任一时刻有且只有一个所有者
	- 当所有者（变量）离开作用域，这个值将被丢弃。

---

- **STRING类型**
	- 这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 `from` 函数基于字符串字面量来创建 `String`
	- 字面量是不可变的。 他是存在栈上
- 为什么 `String` 可变而字面量却不行呢？区别在于两个类型对内存的处理上
	- 文本被直接硬编码进最终的可执行文件中。这使得字符串字面量快速且高效。不过这些特性都只得益于字符串字面量的不可变性
	- 对于 `String` 类型
		- 必须在运行时向内存分配器请求内存
		- 需要一个当我们处理完 `String` 时将内存返回给分配器的方法
	- drop函数
		- 如果你使用过 RAII 模式


---
MOVE
- `let s1 = String::from("hello"); let s2 = s1;`
	- 在 `let s2 = s1` 之后，Rust 认为 `s1` 不再有效
- Rust 永远也不会自动创建数据的 “深拷贝”
	- 任何 **自动** 的复制可以被认为对运行时性能影响较小


---
CLONE
- `let s1 = String::from("hello"); let s2 = s1.clone();`
	- 存储在栈中的数据是不需要的
- Rust 有一个叫做 `Copy` trait 的特殊标注
	- 如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然可用
	- 类似 整形等
	- Rust 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait
		- 有drop 无copy
	- 所有简单类型 都实现了 `Copy` trait
	- 