
- 枚举绑定数据
	- 使用结构体
	- 仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。
		- 用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。IPv4 版本的 IP 地址总是含有四个值在 0 和 255 之间的数字部分。如果我们想要将 `V4` 地址存储为四个 `u8` 值而 `V6` 地址仍然表现为一个 `String`，这就不能使用结构体了。
	- 枚举上也可以定义方法



---


- option枚举
	- 空值的问题在于当你尝试像一个非空值那样使用一个空值，会出现某种形式的错误。因为空和非空的属性无处不在，非常容易出现这类错误。
	- rust中没有空值
	- 在对 `Option<T>` 进行 `T` 的运算之前必须将其转换为 `T`。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况
	- 为了拥有一个可能为空的值，你必须要显式地将其放入对应类型的 `Option<T>` 中。接着，当使用这个值时，必须明确地处理值为空的情况。只要一个值不是 `Option<T>` 类型，你就 **可以** 安全地认定它的值不为空



---


- match控制流
	- ### [通配模式和 `_` 占位符](https://rustwiki.org/zh-CN/book/ch06-02-match.html#%E9%80%9A%E9%85%8D%E6%A8%A1%E5%BC%8F%E5%92%8C-_-%E5%8D%A0%E4%BD%8D%E7%AC%A6)
		- other
		- _
		- match的匹配必须是穷举 的，可以使用通配符。
- if let简单控制流
	- 因为match是穷举的，不方便
	- 