
- 核心功能（之一）是 **所有权**（_ownership_）
	- 管理其使用计算机内存的方式
	- 垃圾回收机制
	- 亲自分配和释放内存
	- 通过所有权系统管理内存
		- 优点 ：在运行时，所有权系统的任何功能都不会减慢程序。 





---

- **所有权的规则**
	- Rust 中的每一个值都有一个被称为其 **所有者**（_owner_）的变量
	- 值在任一时刻有且只有一个所有者
	- 当所有者（变量）离开作用域，这个值将被丢弃。

---

- **STRING类型**
	- 这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 `from` 函数基于字符串字面量来创建 `String`
	- 字面量是不可变的。 他是存在栈上
- 为什么 `String` 可变而字面量却不行呢？区别在于两个类型对内存的处理上
	- 文本被直接硬编码进最终的可执行文件中。这使得字符串字面量快速且高效。不过这些特性都只得益于字符串字面量的不可变性
	- 对于 `String` 类型
		- 必须在运行时向内存分配器请求内存
		- 需要一个当我们处理完 `String` 时将内存返回给分配器的方法
	- drop函数
		- 如果你使用过 RAII 模式


---
MOVE
- `let s1 = String::from("hello"); let s2 = s1;`
	- 在 `let s2 = s1` 之后，Rust 认为 `s1` 不再有效
- Rust 永远也不会自动创建数据的 “深拷贝”
	- 任何 **自动** 的复制可以被认为对运行时性能影响较小


---
CLONE
- `let s1 = String::from("hello"); let s2 = s1.clone();`
	- 存储在栈中的数据是不需要的
- Rust 有一个叫做 `Copy` trait 的特殊标注
	- 如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然可用
	- 类似 整形等
	- Rust 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait
		- 有drop 无copy
	- 所有简单类型 都实现了 `Copy` trait

---
- 函数使用一个值但不获取所有权
	- 使用元组来返回多个值
	- **引用**（_references_）。和借用
		- 允许你使用值但不获取其所有权
		- 函数签名使用 `&` 来表明参数 `s` 的类型是一个引用， 而不是实际的数据
	- 可变引用
		- `s` 改为 `mut`
		- 可变引用 `&mut s`
		- 新函数签名以接受一个可变引用 `some_string: &mut String`
		- 很大的限制：在同一时间，只能有一个对某一特定数据的可变引用。尝试创建两个可变引用的代码将会失败：
			- 优点：避免数据竞争
		- 使用大括号来创建一个新的作用域，避免同时拥有
		- **也** 不能在拥有不可变引用的同时拥有可变引用
			- 使用者可不希望不可变引用的值在他们的眼皮底下突然被改变了
			- 多个不可变引用是可以的
			- 引用的作用域从声明的地方开始一直持续到最后一次使用为止
				- 而不是超出作用域，优点难受啊
- 悬空指针
	- 在 Rust 中编译器确保引用永远也不会变成悬垂状态


---

- 另一个没有所有权的数据类型是 _slice_
- 